# -*- coding: utf-8 -*-
"""InformationDiffusion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-NWHiQmnQqlFLHGBxRtDMNJmjjqCwQhM
"""

# Creation of Array for holding the net value of degree centrlity of each node
 
# importing "array" for array creations
import array as arr
a = arr.array('i', [1,-4,4,-5,3,2,-2,-4,2,5,-1])
# printing original array
print ("The new created array is : ", end =" ")
for i in range (0, 11):
    
    print (a[i], end =" ")
print()
for j in range(0,11):
    if(a[j] > 0):
  
         print("index is the seed node",j+1,"with value",a[j])
# create the dataset graph
graph = {
  '1' : ['2','6','3'],
  '2' : ['8'],
  '3' : ['2','4','6','7','8','1'],
  '4' : ['7','8'],
  '5' : ['2','4','7','8','6'],
  '6' : ['2','4','7','8','5'],
  '7' : ['11','8','9','4'],
  '8' : ['11','4','7','2'],
  '9' : ['4','8','11','7'],
  '10' : ['1','3','4','5'],
  '11' : ['8','9']
      
}

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the information cascade on Root as seed node 1")
bfs(visited, graph, '1')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the information cascade on Root as seed node 3")
bfs(visited, graph, '3')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the information cascade on Root as seed node 5")
bfs(visited, graph, '5')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the information cascade on Root as seed node 6")
bfs(visited, graph, '6')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the information cascade on Root as seed node 9")
bfs(visited, graph, '9')    # function calling


visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the information cascade on Root as seed node 10")
bfs(visited, graph, '10')    # function calling

print()
# Python3 code to find height
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,3,3,1,1,6,6]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree with root 1=",
		ma)
# Python3 code to find height
# Tree generated when the source root is node3
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,0,1,2,3]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree with root as node 3=",ma)
# Python3 code to find height
# of N-ary tree whe source node is 5
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,3,4]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree on root node 5=",
		ma)

# Python3 code to find height
# when the IDT is generated for node 6
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,1,1]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree on root node 6=",
		ma)

# Python3 code to find height
# When IDT is generated for node 9
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,4]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree root node 9=",
		ma)
 # Python3 code to find height
# IDT generated when when soucfe node is 10
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,1,1,2,6,6]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree root node 10=",
		ma)
# find the average height of IDT structure for the whole network
n=int(input("Enter the number of elements to be inserted: "))
a=[]
for i in range(0,n):
    elem=int(input("Enter element: "))
    a.append(elem)
avg=sum(a)/n
print("Average of elements in the list",round(avg,3))
import array as arr
b=arr.array('d',[3.0,2.0,2.0,2.0,2.0,3.0])
for k in range (0,6):
    if(b[k]>avg):
        print("the influential tree is :",k+1,"th tree")

# First networkx library is imported 
# IDT Detected for node 1
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 1") 
# Driver code
G = GraphVisualization()
G.addEdge(1, 3)
G.addEdge(1, 2)
G.addEdge(1, 6)
G.addEdge(3, 8)
G.addEdge(3, 4)
G.addEdge(6, 7)
G.addEdge(6, 5)
G.addEdge(7, 9)
G.addEdge(7, 11)


G.visualize()

# First networkx library is imported 
# IDT Detected for node 3
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 3") 
# Driver code
G = GraphVisualization()
G.addEdge(3, 6)
G.addEdge(3, 8)
G.addEdge(3, 7)
G.addEdge(3, 4)
G.addEdge(3, 2)
G.addEdge(3, 1)
G.addEdge(6, 5)
G.addEdge(8, 11)
G.addEdge(7, 9)


G.visualize()
# First networkx library is imported 
# IDT Detected for node 5
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 5")  
# Driver code
G = GraphVisualization()
G.addEdge(5, 2)
G.addEdge(5, 6)
G.addEdge(5, 8)
G.addEdge(5, 7)
G.addEdge(5, 4)
G.addEdge(8, 11)
G.addEdge(7, 9)



G.visualize()
# First networkx library is imported 
# IDT Detected for node 6
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 6")
# Driver code
G = GraphVisualization()
G.addEdge(6, 7)
G.addEdge(6, 8)
G.addEdge(6, 5)
G.addEdge(6, 2)
G.addEdge(6, 4)
G.addEdge(7, 11)
G.addEdge(7, 9)



G.visualize()
# First networkx library is imported 
# IDT Detected for node 9
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 9") 
# Driver code
G = GraphVisualization()
G.addEdge(9, 4)
G.addEdge(9, 7)
G.addEdge(9, 11)
G.addEdge(9, 8)
G.addEdge(8, 2)




G.visualize()
# First networkx library is imported 
# IDT Detected for node 10
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 10")
# Driver code
G = GraphVisualization()
G.addEdge(10, 6)
G.addEdge(10, 3)
G.addEdge(10, 1)
G.addEdge(10, 4)
G.addEdge(10, 5)
G.addEdge(6, 7)
G.addEdge(6, 8)
G.addEdge(3, 2)
G.addEdge(7, 11)
G.addEdge(7, 19)


G.visualize()

# data set galesburg.net
# second dataset in our expireemnetation.
# Creation of Array for holding the net value of degree centrlity of each node
 
# importing "array" for array creations
import array as arr1
a = arr1.array('i', [1,1,5,1,5,1,-1,0,1,0,2,1,0,-2,-4,0])

for k in range(0,16):
    if(a[k] > 0):
    
         print("index ",k+1,"with seed node",a[k])
# printing original array
print ("The new created array is : ", end =" ")
for i in range (0, 16):
    
    print (a[i], end =" ")
print()
graph = {
  '1' : ['6'],
  '2' : ['11'],
  '3' : ['13','6','7','14','15'],
  '4' : ['5'],
  '5' : ['6','14','15','7','8','17'],
  '6' : ['7','13','15'],
  '7' : ['11'],
  '8' : ['14'],
  '9' : ['17'],
  '10' : [],
  '11' : ['12','16','17','13'],
  '12' : ['17'],
  '13' : [],
  '14' : ['15'],
  '15' : [],
  '16' : ['17'],
  '17' : []
      
}

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 1")
bfs(visited, graph, '1')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 2")
bfs(visited, graph, '2')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 3")
bfs(visited, graph, '3')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 5")
bfs(visited, graph, '4')    # function calling


visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 5")
bfs(visited, graph, '5')    # function calling



visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '6')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 9")
bfs(visited, graph, '9')    # function calling


visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 11")
bfs(visited, graph, '11')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
print()
# Driver Code
print("The infomration cascade on the 12")
bfs(visited, graph, '12')    # function calling
# Python3 code to find height of Information Cascade with root as node 1 
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,1,1,1,3,5,5,5]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree with root as node 1=",
		ma)

 # Python3 code to find height of IDT with root as node 2
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,1,1,1,1]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of information cascade Tree on root as node 2=",
		ma)
 # Python3 code to find height of IDT with root node as node 3

from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,3,6,6,6]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree 3=",
		ma)
 # Python3 code to find height IDT having root node as node 4
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,1,1,1,1,1,1,4,6,9,9]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree 4=",
		ma) 
 # Python3 code to find heightthe IDT with Root as node 5

from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,0,1,4,8,8]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of N-ary Tree with root 5=",
		ma)
 # Python3 code to find height of IDT with root node as Node 6
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,1,4,4,4]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT Tree with root node as node 6=",
		ma)
 # Python3 code to find height of IDT with root node 9
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT Tree on root node 9 =",
		ma)
 # Python3 code to find height of IDT with root as node 11
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT Tree with root 11=",
		ma)
 # Python3 code to find height of IDT with root as node 12
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT Tree with root node as node 12=",
		ma)
 
 # find the average height of IDT structure for the whole network
n=int(input("Enter the number of elements to be inserted: "))
a=[]
for i in range(0,n):
    elem=int(input("Enter element: "))
    a.append(elem)
avg=sum(a)/n
print("Average of elements in the list",round(avg,3))
import array as arr
b=arr.array('d',[4.0,2.0,3.0,4.0,3.0,3.0,0.0,0.0,1,0,1.0,1.0])
for k in range (0,12):
    if(b[k]>avg):
        print("the influential tree is :",k+1,"th tree")

# First networkx library is imported 
# IDT Detected for node 1
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 1") 
# Driver code
G = GraphVisualization()
G.addEdge(1, 6)
G.addEdge(6,13)
G.addEdge(6,7)
G.addEdge(6,15)

G.visualize()
#IDT on Seed Node 2
# First networkx library is imported 
# IDT Detected for node 1
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 2") 
# Driver code
G = GraphVisualization()
G.addEdge(2, 11)
G.addEdge(11,16)
G.addEdge(11,13)
G.addEdge(11,12)
G.addEdge(11,17)
G.visualize()


# IDT on seed node 3
# First networkx library is imported 
# IDT Detected for node 1
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 3 ") 
# Driver code
G = GraphVisualization()
G.addEdge(3, 15)
G.addEdge(3,14)
G.addEdge(3,7)
G.addEdge(3,6)
G.addEdge(3,13)
G.addEdge(7,11)
G.addEdge(11,16)
G.addEdge(11,12)
G.addEdge(11,17)
G.visualize()

# IDT on seed node 4
# First networkx library is imported 

import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 4 ") 
# Driver code
G = GraphVisualization()
G.addEdge(4,5)
G.addEdge(5,15)
G.addEdge(5,7)
G.addEdge(5,14)
G.addEdge(5,6)
G.addEdge(5,8)
G.addEdge(5,17)
G.addEdge(7,11)
G.addEdge(11,16)
G.addEdge(11,12)

G.visualize()

# First networkx library is imported 
# IDT Detected for node 5
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 5") 
# Driver code
G = GraphVisualization()
G.addEdge(5,15)

G.addEdge(5,14)
G.addEdge(5,6)
G.addEdge(5,8)
G.addEdge(5,17)
G.addEdge(5,7)
G.addEdge(7,11)
G.addEdge(6,13)
G.addEdge(11,16)
G.addEdge(11,12)
G.visualize()

# First networkx library is imported 
# IDT Detected for node 6
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 6") 
# Driver code
G = GraphVisualization()
G.addEdge(6,13)
G.addEdge(6,15)
G.addEdge(6,7)
G.addEdge(7,11)
G.addEdge(11,16)
G.addEdge(11,12)
G.addEdge(11,17)

G.visualize()


# First networkx library is imported 
# IDT Detected for node 9
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 9") 
# Driver code
G = GraphVisualization()
G.addEdge(9,17)


G.visualize()

# First networkx library is imported 
# IDT Detected for node 11
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 11") 
# Driver code
G = GraphVisualization()
G.addEdge(11,16)
G.addEdge(11,12)
G.addEdge(11,13)
G.addEdge(11,17)

G.visualize()
# First networkx library is imported 
# IDT Detected for node 12
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
   
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 12") 
# Driver code
G = GraphVisualization()
G.addEdge(12,17)

G.visualize()


#Now expiremnetation on the third dataset
# data set strike datase

# Creation of Array for holding the net value of degree centrlity of each node
 
# importing "array" for array creations
import array as arr1
a = arr1.array('i', [1,2,1,0,1,1,-1,0,-2,2,1,-1,-3,4,-1,0,0,1,0,-1,-2,0,0,-2])

for k in range(0,24):
    if(a[k] > 0):
    
         print("index ",k+1,"with seed node",a[k])
# printing original array
print ("The new created array is : ", end =" ")
for i in range (0, 24):
    
    print (a[i], end =" ")
print()

graph = {
  '1' : ['2'],
  '2' : ['3','5','6'],
  '3' : ['4','9'],
  '4' : ['9'],
  '5' : ['6','9'],
  '6' : ['7','8','9'],
  '7' : ['8','15'],
  '8' : ['9'],
  '9' : ['10','14'],
  '10' : ['11','12','13'],
  '11' : ['12','13'],
  '12' : ['13'],
  '13' : [],
  '14' : ['15','16','17','19','22'],
  '15' : [],
  '16' : ['21'],
  '17' : ['18'],
  '18' : ['19','20'],
  '19' : ['20','22'],
  '20' : ['21'],
  '21' : [],
  '22' : ['23','24'],
   '23' : ['24'],
  '24' : [] 
      
      
}

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 1")
bfs(visited, graph, '1')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 2")
bfs(visited, graph, '2')    # function calling

          
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 3")
bfs(visited, graph, '3')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 5")
bfs(visited, graph, '5')    # function calling

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 6")
bfs(visited, graph, '6')    # function calling
          
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 10")
bfs(visited, graph, '10')    # function calling
          
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 11")
bfs(visited, graph, '11')    # function calling
          
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 14")
bfs(visited, graph, '14')    # function calling
          
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the IDT tree generated on node 18")
bfs(visited, graph, '18')    # function calling

# Python3 code to find height of IDT with root as node 1
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,1,1,1,2,2,3,4,7,7,9,9,9,9,9,10,10,10,11,14,15]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 1 =",
		ma)
 
 # Python3 code to find height of IDT with root as node 2
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,1,1,1,3,6,6,8,8,8,8,8,9,9,9,11,12,13,14,14]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 2=",
		ma)
  
  # Python3 code to find height of IDT with node 3 as root
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,1,2,3,3,3,3,3,4,4,4,6,7,8,9,9]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 3=",
		ma)
 # Python3 code to find height of IDT with root as node 5
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,1,1,2,2,5,5,5,5,5,6,6,6,8,9,10,11,11]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with rtoot as node 5=",
		ma)
 
 # Python3 code to find height of IDT with root as node 6
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,3,3,4,4,4,4,4,5,5,5,7,8,9,10,10]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 6=",
		ma)
 # Python3 code to find height of IDT with root as node 10
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 10=",
		ma)
 
 # Python3 code to find height IDT with node 11
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as 11=",
		ma)
 

# Python3 code to find height of IDT with root as node 14
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,0,0,0,2,3,4,5,5]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 14=",
		ma) 
 # Python3 code to find height of IDT with node 18
# of N-ary tree in O(n)
from collections import deque

MAX = 1001

# Adjacency list to
# store N-ary tree
adj = [[] for i in range(MAX)]

# Build tree in tree in O(n)
def build_tree(arr, n):
	
	root_index = 0

	# Iterate for all nodes
	for i in range(n):

		# if root node, store
		# index
		if (arr[i] == -1):
			root_index = i
		else:
			adj[i].append(arr[i])
			adj[arr[i]].append(i)

	return root_index

# Applying BFS
def BFS(start):
	
	# map is used as visited
	# array
	vis = {}

	q = deque()
	max_level_reached = 0

	# height of root node is
	# zero
	q.append([start, 0])

	# p.first denotes node in
	# adjacency list
	# p.second denotes level of
	# p.first
	p = []

	while (len(q) > 0):
		p = q.popleft()
		vis[p[0]] = 1

		# store the maximum level
		# reached
		max_level_reached = max(max_level_reached,
								p[1])

		for i in range(len(adj[p[0]])):

			# adding 1 to previous level
			# stored on node p.first
			# which is parent of node
			# adj[p.first][i]
			# if adj[p.first][i] is not visited
			if (adj[p[0]][i] not in vis ):
				q.append([adj[p[0]][i],
						p[1] + 1])

	return max_level_reached

# Driver code
if __name__ == '__main__':
	
	# node 0 to node n-1
	parent = [-1,0,0,1,2,4,4]

	# Number of nodes in tree
	n = len(parent)

	root_index = build_tree(parent, n)
	ma = BFS(root_index)
	print("Height of IDT with root as node 18=",
		ma)

# find the average height of IDT structure for the whole network
n=int(input("Enter the number of elements to be inserted: "))
a=[]
for i in range(0,n):
    elem=int(input("Enter element: "))
    a.append(elem)
avg=sum(a)/n
print("Average of elements in the list",round(avg,3))
import array as arr
b=arr.array('d',[6.0,5.0,4.0,0.0,4.0,4.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0])
for k in range (0,24):
    if(b[k]>avg):
        print("the influential tree is :",k+1,"th tree")

# First networkx library is imported 
# IDT Detected for node 1
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 1") 
# Driver code
G = GraphVisualization()
G.addEdge(1,2)
G.addEdge(2,3)
G.addEdge(2,5)
G.addEdge(2,6)
G.addEdge(3,4)
G.addEdge(5,9)
G.addEdge(6,7)
G.addEdge(6,8)
G.addEdge(9,10)
G.addEdge(9,14)
G.addEdge(10,11)
G.addEdge(10,12)
G.addEdge(10,13)
G.addEdge(14,17)
G.addEdge(14,16)
G.addEdge(14,15)
G.addEdge(14,19)
G.addEdge(14,22)
G.addEdge(17,18)
G.addEdge(16,21)
G.addEdge(22,23)
G.addEdge(22,24)
G.visualize()



# First networkx library is imported 
# IDT Detected for node 2
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 2") 
# Driver code
G = GraphVisualization()
G.addEdge(2,3)
G.addEdge(2,5)
G.addEdge(2,6)
G.addEdge(3,4)
G.addEdge(6,9)
G.addEdge(6,7)
G.addEdge(6,8)
G.addEdge(9,10)
G.addEdge(9,14)
G.addEdge(10,11)
G.addEdge(10,12)
G.addEdge(10,13)
G.addEdge(19,20)
G.addEdge(14,17)
G.addEdge(14,16)
G.addEdge(14,15)
G.addEdge(14,19)
G.addEdge(14,22)
G.addEdge(17,18)
G.addEdge(16,21)
G.addEdge(22,23)
G.addEdge(22,24)
G.visualize()

# First networkx library is imported 
# IDT Detected for node 3
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 3") 
# Driver code
G = GraphVisualization()

G.addEdge(3,4)
G.addEdge(3,9)
G.addEdge(9,10)
G.addEdge(9,14)
G.addEdge(10,11)
G.addEdge(10,12)
G.addEdge(10,13)
G.addEdge(14,22)
G.addEdge(14,13)
G.addEdge(14,19)
G.addEdge(14,19)
G.addEdge(14,17)
G.addEdge(14,16)
G.addEdge(14,15)
G.addEdge(22,23)
G.addEdge(22,24)
G.addEdge(19,20)
G.addEdge(17,18)
G.addEdge(16,21)
G.addEdge(14,22)
G.visualize()

# First networkx library is imported 
# IDT Detected for node 5
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 5") 
# Driver code
G = GraphVisualization()

G.addEdge(5,9)
G.addEdge(5,6)
G.addEdge(9,10)
G.addEdge(9,14)
G.addEdge(6,7)
G.addEdge(6,8)
G.addEdge(10,11)
G.addEdge(10,12)
G.addEdge(10,13)
G.addEdge(14,22)
G.addEdge(14,19)
G.addEdge(14,17)
G.addEdge(14,16)
G.addEdge(14,15)
G.addEdge(22,23)
G.addEdge(22,24)
G.addEdge(19,20)
G.addEdge(17,18)
G.addEdge(16,21)
G.visualize()


# First networkx library is imported 
# IDT Detected for node 6
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 6") 
# Driver code
G = GraphVisualization()


G.addEdge(6,9)
G.addEdge(6,7)
G.addEdge(6,8)
G.addEdge(9,10)
G.addEdge(9,14)
G.addEdge(10,11)
G.addEdge(10,12)
G.addEdge(10,13)
G.addEdge(14,22)
G.addEdge(14,19)
G.addEdge(14,17)
G.addEdge(14,16)
G.addEdge(14,15)
G.addEdge(22,23)
G.addEdge(22,24)
G.addEdge(19,20)
G.addEdge(17,18)
G.addEdge(16,21)
G.visualize()


# First networkx library is imported 
# IDT Detected for node 10
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 10") 
# Driver code
G = GraphVisualization()
G.addEdge(10,11)
G.addEdge(10,12)
G.addEdge(10,13)

G.visualize()

# First networkx library is imported 
# IDT Detected for node 11
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 11") 
# Driver code
G = GraphVisualization()
G.addEdge(11,12)
G.addEdge(11,13)

G.visualize()

# First networkx library is imported 
# IDT Detected for node 14
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 14") 
# Driver code
G = GraphVisualization()
G.addEdge(14,22)
G.addEdge(14,19)
G.addEdge(14,17)
G.addEdge(14,16)
G.addEdge(14,15)
G.addEdge(22,23)
G.addEdge(22,24)
G.addEdge(19,20)
G.addEdge(17,18)
G.addEdge(16,21)

G.visualize()


# First networkx library is imported 
# IDT Detected for node 18
import networkx as nx
import matplotlib.pyplot as plt
   
  
# Defining a Class
class GraphVisualization:
    def __init__(self):
          
        # visual is a list which stores all 
        # the set of edges that constitutes a
        # graph
        self.visual = []
          
    # addEdge function inputs the vertices of an
    # edge and appends it to the visual list
    def addEdge(self, a, b):
        temp = [a, b]
        self.visual.append(temp)
          
    # In visualize function G is an object of
    # class Graph given by networkx G.add_edges_from(visual)
    # creates a graph with a given list
    # nx.draw_networkx(G) - plots the graph
    # plt.show() - displays the graph
    def visualize(self):
        G = nx.DiGraph()
        G.add_edges_from(self.visual)
        nx.draw_networkx(G)
        plt.show()
print("the seed node is 18") 
# Driver code
G = GraphVisualization()
G.addEdge(18,19)
G.addEdge(18,20)
G.addEdge(20,21)
G.addEdge(22,23)
G.addEdge(22,24)
G.addEdge(19,22)


G.visualize()